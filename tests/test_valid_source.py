import ast
import hashlib
import sys
from pathlib import Path
from unittest.mock import patch

import pytest
from pysource_minimize import minimize

from .test_invalid_ast import does_compile
from pysource_codegen._codegen import generate_ast
from pysource_codegen._codegen import is_valid_ast
from pysource_codegen._codegen import unparse

sample_dir = Path(__file__).parent / "valid_source_samples"
sample_dir.mkdir(exist_ok=True)


@pytest.mark.parametrize(
    "file", [pytest.param(f, id=f.stem[:12]) for f in sample_dir.glob("*.py")]
)
def test_valid_source(file):
    code = file.read_text()
    print(code)

    tree = ast.parse(code)

    assert is_valid_ast(tree)


def minimize_if_valid(code):
    def bug_found(code):
        try:
            tree = ast.parse(code)
        except:
            return False

        if not does_compile(tree):
            return False

        return not is_valid_ast(tree)

    if bug_found(code):
        print(code)
        code = minimize(code, bug_found)
        print()
        print("minimized:")
        print(code)
        name = sample_dir / f"{hashlib.sha256(code.encode('utf-8')).hexdigest()}.py"
        name.write_text(code)
        return True
    else:
        return False


def generate_valid_source(seed):
    """
    try to find source code which is valid but can not be generated by codegen()

    The use() hook controls if a specific restriction in the code generation should be applied

    """
    print("seed=", seed)

    ignore_index = 0
    ignored_something = True
    max_index = 0

    while ignored_something:
        ignored_something = False

        current_index = 0

        def use():
            nonlocal current_index
            nonlocal ignored_something

            ignore = current_index == ignore_index
            current_index += 1
            if ignore:
                ignored_something = True
            return not ignore

        with patch("pysource_codegen._codegen.use", use):
            tree = generate_ast(seed, node_limit=200, depth_limit=5)

        max_index = max(max_index, current_index)

        try:
            code = unparse(tree)
        except Exception as e:
            print(repr(e))
            continue

        print(f"{seed} {ignore_index} of {max_index} ignored? {ignored_something}")

        if minimize_if_valid(code):
            return True

        ignore_index += 1

    return False


if __name__ == "__main__":
    for file in Path(sys.argv[1]).rglob("*.py"):
        print(file)
        try:
            code = file.read_text("utf-8")
            compile(code, str(file), "exec")
        except:
            print("skip")
            continue
        if minimize_if_valid(code):
            break
