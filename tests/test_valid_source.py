import ast
import hashlib
from pathlib import Path
from unittest.mock import patch

import pytest
from pysource_codegen._codegen import generate_ast
from pysource_codegen._codegen import is_valid_ast
from pysource_codegen._codegen import unparse
from pysource_minimize import minimize

from .test_invalid_ast import does_compile

sample_dir = Path(__file__).parent / "valid_source_samples"
sample_dir.mkdir(exist_ok=True)


@pytest.mark.parametrize(
    "file", [pytest.param(f, id=f.stem[:12]) for f in sample_dir.glob("*.py")]
)
def test_valid_source(file):
    code = file.read_text()

    try:
        tree = ast.parse(code)
    except:
        return

    if not does_compile(tree):
        print("the following code is invalid:\n")
        print(code)
        print()
        assert not is_valid_ast(tree)
        return

    print("the following code is valid:\n")
    print(code)
    print()

    assert is_valid_ast(tree)


def minimize_if_valid(code):
    def bug_found(code):
        try:
            tree = ast.parse(code)
        except:
            return False

        if not does_compile(tree):
            return False

        return not is_valid_ast(tree)

    if bug_found(code):
        code = minimize(code, bug_found)
        print()
        print("minimized:")
        print(code)
        name = sample_dir / f"{hashlib.sha256(code.encode('utf-8')).hexdigest()}.py"
        name.write_text(code)
        return True
    else:
        return False


def generate_valid_source(seed):
    """
    try to find source code which is valid but can not be generated by codegen()

    The use() hook controls if a specific restriction in the code generation should be applied

    """
    print("seed=", seed)

    ignore_index = 0
    ignored_something = True
    max_index = 0

    while ignored_something:
        ignored_something = False

        current_index = 0

        def use():
            nonlocal current_index
            nonlocal ignored_something

            ignore = current_index == ignore_index
            current_index += 1
            if ignore:
                ignored_something = True
            return not ignore

        with patch("pysource_codegen._codegen.use", use):
            tree = generate_ast(seed, node_limit=200, depth_limit=5)

        max_index = max(max_index, current_index)

        try:
            code = unparse(tree)
        except Exception as e:
            print(repr(e))
            continue

        print(f"{seed} {ignore_index} of {max_index} ignored? {ignored_something}")

        if minimize_if_valid(code):
            return True

        ignore_index += 1

    return False


if __name__ == "__main__":
    import json
    import argparse

    parser = argparse.ArgumentParser(
        description="Find valid code which can not be generated by pysource-codegen"
    )
    parser.add_argument("folder", help="Folder to process")
    parser.add_argument("--skip-first", action="store_true", help="Skip the first file")
    args = parser.parse_args()

    db = Path("checked_valid_source_files")

    if db.exists():
        checked = set(json.loads(db.read_text()))
    else:
        checked = set()

    globbed_files = set(map(str, Path(args.folder).rglob("*.py")))

    all_files = globbed_files - checked

    if not all_files:
        all_files = globbed_files
        checked = set()

    is_first = True

    for file in map(Path, sorted(all_files)):
        print(file)
        try:
            code = file.read_text("utf-8")
            compile(code, str(file), "exec")
        except:
            print("skip")
            continue
        if is_first and args.skip_first:
            checked.add(str(file))
            is_first = False
            continue
        if minimize_if_valid(code):
            break

        checked.add(str(file))

    db.write_text(json.dumps(sorted(checked)))
